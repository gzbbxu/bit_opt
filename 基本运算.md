# bit_opt

#### 1.左移位运算符

把整数a的各二进位全部左移n位，高位丢弃，低位补0。左移n位其实就是乘以2的n次方

- 由于左移是丢弃最高位，0补最低位，**所以符号位也会被丢弃，左移出来的结果值可能会改变正负性**

```objc
:将2左移1位
2<<1;
补码:                           00000000 00000000 00000000 00000010
左移:                          00000000 00000000 00000000 00000010
左边的砍掉,右边补0                00000000 00000000 00000000 00000100
结果:4
```

#### 右移位运算符

把整数a的各二进位全部右移n位，**保持符号位不变。右移n位其实就是除以2的n次方**

- 为正数时， 符号位为0，最高位补0
- 为负数时，符号位为1，最高位是补0或是补1

```objc
将4右移2位
4>>2;
补码:                           00000000 00000000 00000000 00000100
右移:                             00000000 00000000 00000000 00000100
右边的砍掉,左边补0                00000000 00000000 00000000 00000001
结果:1


🌰:将-4右移2位
-4>>2;
原码:                           10000000 00000000 00000000 00000100        
反码:                           11111111 11111111 11111111 11111011        
补码:                           11111111 11111111 11111111 11111100
右移:                             11111111 11111111 11111111 11111100
右边的砍掉,左边补1                11111111 11111111 11111111 11111111
反码:                           11111111 11111111 11111111 11111110
原码                            10000000 00000000 00000000 00000001
结果:-1
```

#### 移位操作符注意:针对补码进行的

在了解移位操作符和位操作符之前，我们需要知道一个十进制的整数是如何在计算机中存储的，以int a = 10 为例，int型占4个字节，一个字节有8位，正数十以二进制存储在这32位中，其在内存中的存储如下，为方便视图中间部分已省略。注意：注意:**移位操作都是针对补码进行的，正数的原码、补码、反码相同，负数的原码取反得反码，反码加一得补码。**

**如果是有符号数字,最高位(左边第一位)表示符号,0表示正数,1表示负数！！**

| 0    | 0    | 0    | .    | .    | .    | .    | .    | 0    | 1    | 0    | 1    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |      |      |      |      |      |



#### <<1. 左移操作符

移动正数和负数时一样将这32位向左移动，后面空的位用0代替。例如：a<<1（将a左移一位）得到

| 0    | 0    | 0    | .    | .    | .    | .    | 0    | 1    | 0    | 1    | 0    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |      |      |      |      |      |

**需要注意的是<<只是操作符，如加减号一样，a的值并没有变，这与a++是不同的。**



#### >>2. 右移操作符

**移动正数时，前面的补0，移动负数时，前面补1，注意:一个负数一直右移，最终得到-1。**

| 1    | 1    | 1    | .    | .    | .    | .    | 1    | 1    | 1    | 1    | 1    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |      |      |      |      |      |

#### 位操作符注意:针对补码进行的

**针对位操作符，他们的操作数必须是整数**





#### 为什么1向左移动31位（1 << 31 ）结果是-2147483648

```
// 1 << 31

0000 0000 0000 0000 0000 0000 0000 0001
常理来说，左移31位
1000 0000 0000 0000 0000 0000 0000 0000
但是《JavaScript高级程序设计》里面又说左移不会影响操作数的
符号位，那么结果应该是
0000 0000 0000 0000 0000 0000 0000 0000
这样一个全0的二进制计算机是怎么识别成-2147483648，
```

因为这里左移实际上把1移动到了符号位上，其实已经是属于溢出的异常情况，实际上为

```
1000 0000 0000 0000 0000 0000 0000 0000
```

这里的意思应该是想表达：“移位不会导致符号位移动”。**正确理解应该是移动的数值位会和符号位进行 | 操作。**

不过你可以试试-2147483648 << 1

结果是0，最高位即是符号位又是数值位表示最大的32位负数，这个数值位还是被移动了。